{"root":{"data":{"id":"debo8gf7ob40","created":1763453896933,"text":"C++面试指北"},"children":[{"data":{"id":"debobh9ww340","created":1763454133882,"text":"C++基础语法","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"decjvgs5qeo0","created":1763543154498,"text":"C++的构建过程","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"decjwcqy0lk0","created":1763543224082,"text":"1. 预处理"},"children":[{"data":{"id":"decjx566ksg0","created":1763543285953,"text":"处理#define、#include等，生成.i文件"},"children":[]}]},{"data":{"id":"decjwf5uv2g0","created":1763543229337,"text":"2. 编译"},"children":[{"data":{"id":"decjxj28vy00","created":1763543316190,"text":"将预处理之后代码翻译成汇编语言，生成.s文件"},"children":[]}]},{"data":{"id":"decjwkvz2xc0","created":1763543241801,"text":"3. 汇编"},"children":[{"data":{"id":"decjxvfyzbc0","created":1763543343142,"text":"将汇编语言翻译成机器码，生成.o文件"},"children":[]}]},{"data":{"id":"decjwnkqugg0","created":1763543247652,"text":"4. 链接"},"children":[{"data":{"id":"decjy731nwg0","created":1763543368481,"text":"将所有的.o文件和库文件结合，生成最终可执行文件.exe或者a.out"},"children":[]}]}]},{"data":{"id":"deboekxjcvs0","created":1763454376933,"text":"sizeof","expandState":"collapse","layout":null},"children":[{"data":{"id":"debofwfanqw0","created":1763454480315,"text":"指针的大小是固定的，取决于处理器的位数，64位的大小是8","progress":null,"layout":null},"children":[]},{"data":{"id":"debogadtb5c0","created":1763454510701,"text":"数组作为函数参数传递时会退化成指针，大小按照指针计算","layout":null},"children":[]},{"data":{"id":"debohm07o2o0","created":1763454614364,"text":"结构体大小要考虑字节对齐","layout":null},"children":[]},{"data":{"id":"debohx2djvk0","created":1763454638439,"text":"直接计算字符串数组的时候要算上末尾的‘\\0’，也就是正常长度+1","layout":null},"children":[]},{"data":{"id":"dee8num4a4w0","created":1763714645399,"text":"sizeof一个空类的大小是1"},"children":[{"data":{"id":"dee8o31knu00","created":1763714663748,"text":"因为C+=要求每个对象都是有独一无二的内存地址，所以给空类分配1字节地址，空类创建的对象也都有不同的地址"},"children":[]}]}]},{"data":{"id":"deboez9s0ds0","created":1763454408148,"text":"sizeof和strlen的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"deboj44yo0w0","created":1763454732197,"text":"strlen是C标准库中的一个函数，计算C风格字符串（以'\\0'结尾的字符串数组）的长度，不包括‘\\0’","layout":null},"children":[]},{"data":{"id":"debok9fh7f40","created":1763454822081,"text":"sizeof是C++编译期间计算的操作符，用于计算数据类型和对象的字节数，当计算的是字符串数组时，包括结尾的'\\0'","layout":null},"children":[]}]},{"data":{"id":"deboisn8pg80","created":1763454707181,"text":"数组作为参数时退化成指针","expandState":"collapse","layout":null},"children":[{"data":{"id":"deboq3xz7x40","created":1763455280324,"text":"如果是把数组当做正常的参数传递给一个函数时，此时传递的是数组的指针，所以sizeof就是指针的大小","layout":null},"children":[]},{"data":{"id":"deboqpah2bs0","created":1763455326792,"text":"但是如果传递的是一个数组的引用（保留大小信息），此时函数内部sizeof就数组的正常大小","expandState":"collapse","layout":null},"children":[{"data":{"id":"debpdv18y0g0","created":1763457141671,"text":"// func 的参数是一个对“包含5个int的数组”的引用\nvoid func(int (&arr)[5]) {\n\tstd::cout << \"通过引用传递, sizeof(arr) = \" << sizeof(arr) << std::endl;\n}\nint main() {\n\tint my_arr[5] = {};\n\tfunc(my_arr); // 传递 my_arr\n\t// int another_arr[6] = {};\n\t// func(another_arr); // 编译错误！因为类型不匹配（[6] vs [5]）\n}","layout":null},"children":[]}]}]},{"data":{"id":"deboeztn5000","created":1763454409349,"text":"const关键字","expandState":"collapse","priority":1,"layout":null},"children":[{"data":{"id":"debozws567k0","created":1763456048376,"text":"const是一个关键字，用来表示常量，可以修饰变量、函数、指针","layout":null},"children":[]},{"data":{"id":"debp0n0dzo00","created":1763456105470,"text":"1.const修饰变量时，正常是不能被修改的，使用const_cast可以强行修改，但是一般会被编译器优化，不起作用","layout":null},"children":[]},{"data":{"id":"debp28njj940","created":1763456230947,"text":"2.const修饰函数参数时，证明函数内部不会修改该参数，如果内部修改了，编译时会报错","layout":null},"children":[]},{"data":{"id":"debp2qjsj7s0","created":1763456269902,"text":"3.const可以修改函数返回值，这样可以保证函数返回值更安全，不会被误修改","layout":null},"children":[]},{"data":{"id":"debp3kdlxgg0","created":1763456334832,"text":"4.const修饰指针或者引用","expandState":"expand","layout":null},"children":[{"data":{"id":"debp4559nc00","created":1763456380040,"text":"1.指向只读变量的指针，可以更改指针指向的只读变量，但是不能通过指针更改只读变量的值","layout":null},"children":[]},{"data":{"id":"debp632rl8o0","created":1763456532263,"text":"2.只读指针，初始化时必须指向一个地址，可以通过指针修改变量的值，但是不能更改指向的变量","layout":null},"children":[]},{"data":{"id":"debp6sw1czs0","created":1763456588453,"text":"3.只读指针指向只读变量，const int a =10; const int* const p = &a,指针指向的变量不能修改，也不能通过指针修改变量的值","layout":null},"children":[]},{"data":{"id":"debp8544ye80","created":1763456693428,"text":"4.常量引用，无法通过常量引用修改常量的值，只是引用","layout":null},"children":[]}]},{"data":{"id":"debp98t86540","created":1763456779840,"text":"4.修饰成员函数","layout":null},"children":[{"data":{"id":"debp9dmbyqw0","created":1763456790307,"text":"const修饰成员函数时，就可以让const对象调用const成员函数，正常const对象无法调用非const成员函数","layout":null},"children":[]}]}]},{"data":{"id":"debof07mu2o0","created":1763454410195,"text":"static关键字","expandState":"collapse","priority":1,"layout":null},"children":[{"data":{"id":"debpftl44qo0","created":1763457295247,"text":"可以用于变量、函数、和类","layout":null},"children":[]},{"data":{"id":"debpg3qyx6w0","created":1763457317369,"text":"1.修饰全局变量，把该变量的作用域限定到当前文件中，其他文件无法访问该变量，该变量会在程序启动时初始化，声明周期和函数一样长（变量放在全局存储区）","layout":null},"children":[]},{"data":{"id":"debpizic3zs0","created":1763457543232,"text":"2.修饰局部变量，可以使得变量在函数结束调用后不会被销毁，下次调用函数可以继续使用，该局部变量放在全局存储区，生命周期贯穿整个程序","layout":null},"children":[]},{"data":{"id":"debpk3psyeg0","created":1763457630755,"text":"3.修饰函数，使得函数的作用域限于该文件，其他文件无法访问该函数，此时该函数的链接属性就是内部链接，其他文件可以定义一样名字的函数，但是不能声明引入该函数","layout":null},"children":[]},{"data":{"id":"debpmqyx2dc0","created":1763457838100,"text":"4.修饰类成员变量和类成员函数，这些成员在所有类对象中共享，可以使得不需要创建对象就可以访问","layout":null},"children":[]}]},{"data":{"id":"decjgpr0irc0","created":1763541998558,"text":"C++语言层面的链接属性","priority":2,"expandState":"collapse","layout":null},"children":[{"data":{"id":"decjgwhzhs00","created":1763542013249,"text":"1.外部链接","layout":null},"children":[{"data":{"id":"decjmrpw7ts0","created":1763542473029,"text":"普通的全局变量，非static","layout":null},"children":[]},{"data":{"id":"decjmvbdooo0","created":1763542480858,"text":"普通的函数，非static，非inline","layout":null},"children":[]},{"data":{"id":"decjn8ojhvk0","created":1763542509952,"text":"使用extern声明的变量或函数","layout":null},"children":[]}]},{"data":{"id":"decjnjbhju80","created":1763542533107,"text":"2.内部链接","layout":null},"children":[{"data":{"id":"decjnm9wwt40","created":1763542539543,"text":"static修饰的全局变量或函数","layout":null},"children":[]},{"data":{"id":"decjo0faiw80","created":1763542570343,"text":"C++中const修饰的全局变量，C语言中const修饰的是外部链接","layout":null},"children":[]},{"data":{"id":"decjoff0gq80","created":1763542602978,"text":"匿名命名空间中的所有内容","layout":null},"children":[{"data":{"id":"decjox3nk2o0","created":1763542641473,"text":"namespace {\n\tvoid helperFunction() { ... } // 自动具有内部链接\n\tclass LocalHelper { ... };    // 类型也可以限制在内部\n}","layout":null},"children":[]}]}]},{"data":{"id":"decjomm7nxc0","created":1763542618650,"text":"3. 无链接","layout":null},"children":[{"data":{"id":"decjoqlq2ds0","created":1763542627328,"text":"代码块内的内容","layout":null},"children":[]},{"data":{"id":"decjpbmr6w00","created":1763542673103,"text":"局部变量","layout":null},"children":[]},{"data":{"id":"decjpf6fjrs0","created":1763542680823,"text":"函数参数","layout":null},"children":[]},{"data":{"id":"decjpl2ocv40","created":1763542693656,"text":"函数体内部定义的类或者结构体","layout":null},"children":[]}]}]},{"data":{"id":"debof0phvi80","created":1763454411275,"text":"volatile","expandState":"collapse","layout":null},"children":[{"data":{"id":"debppdelbmo0","created":1763458043666,"text":"用于修饰变量，表示变量的值可能在任何时候被外部因素更改","layout":null},"children":[]},{"data":{"id":"debppq1q6hs0","created":1763458071186,"text":"当一个变量被声明为volatile，编译器会禁止对该变量优化，确保每次读取该变量是从内存中，而不是从寄存器或者缓存中读取","layout":null},"children":[]},{"data":{"id":"debpstg4y400","created":1763458313680,"text":"当volatile声明一个变量，就是告诉编译器该变量可能会被寄存器其他地方改变，因为编译器为了效率，可能把变量缓存到寄存器中，不再从内存中读取（慢），比如多线程情况，另一个线程可能修改了这个变量，编译器应该重新从内存读取，volatile就是为了这种情况","layout":null},"children":[]}]},{"data":{"id":"debof1at1u80","created":1763454412564,"text":"字节对齐","expandState":"collapse","layout":null},"children":[{"data":{"id":"decijvkk48w0","created":1763539425211,"text":"字节对齐是内存分配的一种策略；在分配内存时，编译器会自动调整数据结构的内存布局，使得数据成员的起始地址和其自然对齐边界（一般为自己大小的倍数）相匹配","layout":null},"children":[]},{"data":{"id":"decilenohd40","created":1763539545122,"text":"如果数据存储不进行适当对齐，可能导致存取效率低下","layout":null},"children":[]},{"data":{"id":"decilxi64e80","created":1763539586148,"text":"字节对齐有助于提高内存访问速度，但是可能造成一些内存空间浪费","layout":null},"children":[]},{"data":{"id":"decimzcncg80","created":1763539668532,"text":"需要额外注意结构体的对齐，结构体中，每个成员都会为了使下一个成员能够在合适位置开始而填充自己后面的字节，最后一个成员会为了对齐整个结构体而填充，结构体的对齐是根据最长成员的大小来对齐，（也就是倍数）","layout":null},"children":[]},{"data":{"id":"decipffb2740","created":1763539860250,"text":"更改对齐规则：全局可以使用#pragma pack来更改对齐规则，但是会降低访问性能，C++11及以上，可以通过alignas关键字来指定对齐要求","layout":null},"children":[]},{"data":{"id":"deciqqq365s0","created":1763539963210,"text":"大多数动态内存分配函数（malloc和new）会自动分配对齐的内存","layout":null},"children":[]}]},{"data":{"id":"decir9n4u5s0","created":1763540004391,"text":"字节序：大端序和小端序","expandState":"collapse","layout":null},"children":[{"data":{"id":"deciridmh080","created":1763540023407,"text":"字节序指的是多字节数据类型（如整数，浮点数）中，字节在内存中的存储顺序","layout":null},"children":[]},{"data":{"id":"decish7wwow0","created":1763540099249,"text":"大端字节序是指高位字节存储在低地址处，低位字节存储在高地址处；小端字节序则是反过来","layout":null},"children":[]},{"data":{"id":"decitgsn8js0","created":1763540176690,"text":"网络传输过程中通常使用大端字节序","layout":null},"children":[]},{"data":{"id":"decitwvbt340","created":1763540211680,"text":"具体的操作系统（LinxuX86、windowsX86、mac）使用的是小端字节序","layout":null},"children":[]}]},{"data":{"id":"deciv0xlzig0","created":1763540298890,"text":"C++中的class和struct的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"deciv7upq1c0","created":1763540313952,"text":"C++为了兼容C语言保留了struct关键字，并扩充了含义","layout":null},"children":[]},{"data":{"id":"deciw0hhm740","created":1763540376279,"text":"C语言中struct只能包含成员，不能包含成员函数，C++里的struct类似class,都可以包含","layout":null},"children":[]},{"data":{"id":"deciwqx6nx40","created":1763540433824,"text":"Class中成员默认是private属性，struct成员默认是public属性","layout":null},"children":[]},{"data":{"id":"deciwu1s3880","created":1763540440633,"text":"class继承默认是private继承，struct默认是public继承","layout":null},"children":[]},{"data":{"id":"deciy1g1f1k0","created":1763540535096,"text":"class可以用于定义模板参数，struct不能用来定义模板参数","layout":null},"children":[]}]},{"data":{"id":"deciylmtev40","created":1763540579042,"text":"c++中define和inline的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"decize0dh680","created":1763540640813,"text":"宏定义（#define）和内联函数（inline）都是为了减少函数调用开销和提高代码运行效率的机制","layout":null},"children":[]},{"data":{"id":"decj0a366p40","created":1763540710638,"text":"#define是预处理命令的一种，一般用来定义宏常量和创建宏函数","layout":null},"children":[]},{"data":{"id":"decj1o5poqo0","created":1763540819631,"text":"inline在函数开头声明，一般会把内联函数复制到调用处，使用空间换时间的策略来提高效率，但是具体是否复制需要根据编译器的判断，如果内联函数很长，可能不会复制，还是作为普通函数","layout":null},"children":[]},{"data":{"id":"decj330pkps0","created":1763540930344,"text":"#define和inline的主要区别在于#define不会进行类型检查只是简单的替换文本，可能导致错误，inline会进行类型检查，更加安全","layout":null},"children":[]}]},{"data":{"id":"decj46nkb200","created":1763541016620,"text":"c++中define和typedef的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"decj4ib1vvk0","created":1763541041985,"text":"两者都是C++中用来定义别名的方法","layout":null},"children":[]},{"data":{"id":"decj54sjduo0","created":1763541090932,"text":"区别","expandState":"expand","layout":null},"children":[{"data":{"id":"decj5f1oo6w0","created":1763541113253,"text":"1.语法，#define只是进行文本替换，不进行类型检查，typedef是一种类型定义关键字，会进行类型检查（编译阶段处理）","layout":null},"children":[]},{"data":{"id":"decj6jbvepc0","created":1763541200940,"text":"2.作用域，#define没有作用域的限制，宏定义之后就都可以使用，typedef有作用域的限制，通常定义浮渣类型的别名，方便进行维护","layout":null},"children":[]},{"data":{"id":"decj866jpnk0","created":1763541329048,"text":"3.模板支持，#define不支持模板，typedef支持模板","layout":null},"children":[]}]}]},{"data":{"id":"decj9ssa7s00","created":1763541456616,"text":"c++中的explicit","expandState":"collapse","layout":null},"children":[{"data":{"id":"decjc0jbaww0","created":1763541630216,"text":"explicit通常用于构造函数的声明中，防止隐式类型转换，当一个参数传给构造函数后，如果构造函数声明中使用了explicit关键字，就只能使用显示转换，不能隐式转换，防止编译器自动执行预期之外的类型转换","layout":null},"children":[]}]},{"data":{"id":"decjewzlork0","created":1763541857586,"text":"C++中extern的作用","expandState":"collapse","layout":null,"priority":1},"children":[{"data":{"id":"decjpycghn40","created":1763542722546,"text":"首先了解声明和定义，extern是声明","layout":null},"children":[]},{"data":{"id":"decjq8wgjko0","created":1763542745523,"text":"C++支持分离式编译，支持文件之间共享数据，extern就是告诉编译器这个变量在别处有定义，让去别处找","layout":null},"children":[]},{"data":{"id":"decjr2u7gn40","created":1763542810691,"text":"常量全局变量的外部链接，全局常量默认是内部链接的，如果想在文件之间共享，需要定义时指明extern，比如：","layout":null},"children":[{"data":{"id":"decjsa624y80","created":1763542905009,"text":"//fileA.cpp\nextern const int i = 1;        //定义\n//fileB.cpp                    //声明\nextern const int i;","layout":null},"children":[]}]},{"data":{"id":"decjzbeudbk0","created":1763543456266,"text":"c++中可以用extern C关键字来指定外部C链接，从而使用一些C的静态库"},"children":[]},{"data":{"id":"decjt7bmm0o0","created":1763542977179,"text":"extern在编译和链接的过程，编译期间，编译器会在extern处声明一个符号引用，在链接期间，链接器会把多个目标文件链接成一个可执行文件，会找到声明的符号引用，然后在其他源文件中找到对应的定义，然后链接起来","layout":null},"children":[]}]},{"data":{"id":"decjzy4ywhs0","created":1763543505735,"text":"extern C","expandState":"collapse"},"children":[{"data":{"id":"deck05s3z8w0","created":1763543522372,"text":"如果不用extern C，但是还需要使用C语言中的某些函数等，就会因为C++和C语言在编译和链接时使用的命名规则不同而报错，导致C++无法调用C语言编写的函数或变量","expandState":"expand"},"children":[]},{"data":{"id":"deck24wnink0","created":1763543677198,"text":"使用extern C 之后，在对应位置写入C语言函数或者变量，外面的C++程序就能调用其中的C语言代码，比如：","expandState":"expand"},"children":[{"data":{"id":"deck2x828w00","created":1763543738838,"text":"// C 语言代码\n#include <stdio.h>\n\nvoid print_message(const char* message) {\n\tprintf(\"%s\\n\", message);\n}","expandState":"expand"},"children":[]},{"data":{"id":"deck336no940","created":1763543751813,"text":"// C++ 代码\nextern \"C\" {\n\t// 声明 C 语言函数\n\tvoid print_message(const char* message);\n}\nint main() {\n\t// 调用 C 语言函数\n\tprint_message(\"Hello, world!\");\n\treturn 0;\n}"},"children":[]}]}]},{"data":{"id":"deck499ckgg0","created":1763543843401,"text":"C++ mutable","expandState":"collapse"},"children":[{"data":{"id":"deck4mqsft40","created":1763543872754,"text":"mutable是一个C++的关键字，修饰类中的成员变量，表示该变量在一个const成员函数内也能被修改，mutable中文意思是多变的，是constant的反义词"},"children":[]}]},{"data":{"id":"deck63z7iw80","created":1763543988632,"text":"C++ 的四种强制类型转换","expandState":"collapse"},"children":[{"data":{"id":"deck6a0516o0","created":1763544001749,"text":"C语言中一般使用（typename）expression来进行强制类型转换，C++则是更推荐使用下面4种"},"children":[]},{"data":{"id":"deck8j0h8o80","created":1763544178089,"text":"static_cast"},"children":[{"data":{"id":"deck964zgug0","created":1763544228428,"text":"用法: static_cast <new_type> (expression)"},"children":[]},{"data":{"id":"deck98zzuxs0","created":1763544234656,"text":"一般和C语言强制类型转换相同"},"children":[]}]},{"data":{"id":"deck8q35feo0","created":1763544193488,"text":"dynamic_cast"},"children":[{"data":{"id":"deck9m2fhew0","created":1763544263102,"text":"用法: dynamic_cast <new_type> (expression)"},"children":[]},{"data":{"id":"deck9rzxbpk0","created":1763544276011,"text":"运行时进行类型检查，一般用于父子类层次结构的安全类型转换"},"children":[]}]},{"data":{"id":"deck8uqha1s0","created":1763544203606,"text":"const_cast"},"children":[{"data":{"id":"deckabqjhgg0","created":1763544318979,"text":"用法: const_cast <new_type> (expression)"},"children":[]},{"data":{"id":"deckad5lks00","created":1763544322066,"text":"new_type必须是一个指针、引用、或者指向对象类型成员的指针"},"children":[]},{"data":{"id":"deckas9hx7k0","created":1763544354954,"text":"可以用于删除const对象的const属性"},"children":[]}]},{"data":{"id":"deck8y4sfhk0","created":1763544211002,"text":"reinterpret_cast"},"children":[{"data":{"id":"deckbjszd880","created":1763544414905,"text":"用法: reinterpret_cast <new_type> (expression)"},"children":[]},{"data":{"id":"deckbgzxu080","created":1763544408795,"text":"reinterpret_cast用于在不同类型之间进行低级别的转换。"},"children":[]}]}]}]},{"data":{"id":"debodg0e1s00","created":1763454287857,"text":"C++ 面向对象","layout":null,"expandState":"expand"},"children":[{"data":{"id":"dedcq7j1jzk0","created":1763624554723,"text":"面向对象的三大特性","expandState":"collapse"},"children":[{"data":{"id":"dedcr0a95gg0","created":1763624617318,"text":"封装"},"children":[{"data":{"id":"dedcrsdulu00","created":1763624678485,"text":"封装是将数据和操作这些数据的函数组合到一个类的过程"},"children":[]},{"data":{"id":"dedcs4cjpc00","created":1763624704528,"text":"封装的目的：隐藏类内部的实现细节，仅暴露必要的接口给外部"},"children":[]},{"data":{"id":"dedcsrcv41c0","created":1763624754613,"text":"通过封装，我们可以控制类成员访问的级别（public、private、protected），限制对类内部数据的直接访问，确保数据的安全性"},"children":[]}]},{"data":{"id":"dedcrbyj3sg0","created":1763624642730,"text":"继承"},"children":[{"data":{"id":"dedcttax6d40","created":1763624837213,"text":"继承是一个类（派生类）从另一个类（基类）那里获得属性和方法的过程"},"children":[]},{"data":{"id":"dedcuaxt9ug0","created":1763624875603,"text":"继承允许我们创建具有共享代码的类层次结构，减少代码重复性，提高代码复用性和可维护性"},"children":[]},{"data":{"id":"dedcutzlnjk0","created":1763624917070,"text":"C++中，访问修饰符（public、protected、private）控制了派生类对基类成员的访问权限"},"children":[]}]},{"data":{"id":"dedcrdi5qko0","created":1763624646094,"text":"多态"},"children":[{"data":{"id":"dedcw1t36d40","created":1763625012454,"text":"多态是允许不同类的对象使用相同的接口名字，但是具有不同的实现特性"},"children":[]},{"data":{"id":"dedcwv13xxk0","created":1763625076066,"text":"C++中，多态主要通过虚函数和抽象基类来实现"},"children":[]},{"data":{"id":"dedcx5b61k00","created":1763625098442,"text":"虚函数允许派生类重写基类中的方法，抽象基类至少包含一个纯虚函数，不能被实例化，只能作为其他派生类的基类"},"children":[]}]}]},{"data":{"id":"deddetcljio0","created":1763626482962,"text":"C++的类成员访问权限","expandState":"collapse"},"children":[{"data":{"id":"deddf0iofvc0","created":1763626498567,"text":"pubilc（公共）"},"children":[]},{"data":{"id":"deddf6tvrs00","created":1763626512305,"text":"private（私有）"},"children":[]},{"data":{"id":"deddf9wrz340","created":1763626519011,"text":"protected（被保护）"},"children":[{"data":{"id":"deddglck8dk0","created":1763626622274,"text":"类似私有成员，但是能被派生类访问"},"children":[]}]}]},{"data":{"id":"deddhvzzbk00","created":1763626723822,"text":"C++派生类的继承","expandState":"collapse"},"children":[{"data":{"id":"deddi3kd6hc0","created":1763626740292,"text":"（真正的继承）派生类在创建的时候，内存里包含了基类的所有成员变量"},"children":[]},{"data":{"id":"deddio730zc0","created":1763626785201,"text":"（继承但是无法访问）基类通过访问修饰符（public、private、protected）来控制派生类对基类成员的访问权限，比如private，派生类无法直接访问"},"children":[]},{"data":{"id":"deddkdzslh40","created":1763626919721,"text":"（根本没有继承）有些特殊的函数派生类是不能继承基类的，比如有："},"children":[{"data":{"id":"deddkw5sou00","created":1763626959266,"text":"构造函数和析构函数"},"children":[]},{"data":{"id":"deddl3015bk0","created":1763626974155,"text":"友元函数（父亲的朋友不一定是儿子的朋友）"},"children":[]},{"data":{"id":"deddlle6hpc0","created":1763627014193,"text":"赋值运算符重载operator=，编译器默认为派生类生成一个operator，它会自动调用基类的operator，但这不叫继承"},"children":[]}]}]},{"data":{"id":"deddnbxl5ag0","created":1763627150327,"text":"C++中重载、重写和隐藏的区别","expandState":"collapse"},"children":[{"data":{"id":"deddskdsr8g0","created":1763627560542,"text":"重载（同级竞争）：在同一个作用域（通常在一个类中），函数名相同，参数列表不同"},"children":[{"data":{"id":"deddu2u31qo0","created":1763627679073,"text":"同一作用域"},"children":[]},{"data":{"id":"deddu6g7z200","created":1763627686942,"text":"和virtual无关，有没有都可以重载"},"children":[]},{"data":{"id":"dedduewcqzs0","created":1763627705332,"text":"和返回值无关，只改变返回值无法重载"},"children":[]},{"data":{"id":"dedduoa8xe80","created":1763627725763,"text":"编译时多态"},"children":[]}]},{"data":{"id":"deddutnl00g0","created":1763627737453,"text":"重写（子承父业）：派生类中重新定义基类中的虚函数"},"children":[{"data":{"id":"deddvdbjks80","created":1763627780261,"text":"基类函数必须有virtual关键字"},"children":[]},{"data":{"id":"deddvk4xq6g0","created":1763627795099,"text":"函数名，参数列表、返回值必须完全一致"},"children":[]},{"data":{"id":"deddyusualc0","created":1763628053404,"text":"C++11中最好在派生类重写的函数后加上override关键字，可以防止意外被隐藏"},"children":[]},{"data":{"id":"deddvryhpvc0","created":1763627812123,"text":"运行时多态"},"children":[]}]},{"data":{"id":"deddvu38a740","created":1763627816763,"text":"隐藏（遮挡视线）：也叫重定义，派生类的函数屏蔽了同名的基类函数，只要名字相同即可"},"children":[{"data":{"id":"deddxlwyetk0","created":1763627955698,"text":"如果参数相同，就看基类有没有virtual关键字，如果有就是重写，没有就是隐藏"},"children":[]},{"data":{"id":"deddy38gqfk0","created":1763627993399,"text":"如果参数不同，就不管基类的virtual关键字，全是隐藏"},"children":[]}]}]},{"data":{"id":"deddztq3ws80","created":1763628129426,"text":"C++类对象初始化和析构的顺序","expandState":"collapse"},"children":[{"data":{"id":"dede05tdn000","created":1763628155746,"text":"初始化顺序"},"children":[{"data":{"id":"dede0etjyv40","created":1763628175347,"text":"1. 基类初始化顺序，如果当前类继承一个或者多个基类，一般按照声明顺序初始化，但是在存在虚继承的情况，优先虚继承初始化"},"children":[]},{"data":{"id":"dede1uqheog0","created":1763628288354,"text":"2. 成员变量初始化顺序，注意！！！只和声明顺序有关"},"children":[]},{"data":{"id":"dede2ffm61c0","created":1763628333410,"text":"3. 执行构造函数，在基类和成员变量初始化完成后，再执行构造函数"},"children":[]}]},{"data":{"id":"dede0cnou7s0","created":1763628170639,"text":"析构顺序"},"children":[{"data":{"id":"dedef2po3zs0","created":1763629324453,"text":"类的析构顺序和构造顺序完全相反"},"children":[]}]}]},{"data":{"id":"dedeg1yqme80","created":1763629401189,"text":"C++析构函数可以抛出异常吗？","expandState":"collapse"},"children":[{"data":{"id":"dedegdq4dw00","created":1763629426790,"text":"语法层面没有禁止，但是实践不推荐"},"children":[]}]},{"data":{"id":"dedehgd45qw0","created":1763629510898,"text":"C++的深拷贝和浅拷贝","expandState":"collapse"},"children":[{"data":{"id":"dedehxci13k0","created":1763629547866,"text":"浅拷贝"},"children":[{"data":{"id":"dedeq6e2rq80","created":1763630194465,"text":"仅仅复制对象的基本类型成员和指针成员的值（按照bit复制）不复制指针指向的内存，可能出现两个对象共享相同的资源（两个指针指向同一块内存）"},"children":[]},{"data":{"id":"dedes71hcl40","created":1763630352609,"text":"可能出现悬空指针，内存泄漏和意外修改共享资源等"},"children":[]},{"data":{"id":"dedesnscnbk0","created":1763630389062,"text":"当两个类中的两个指针指向同一块内存时，析构时，第一个类会把这块内存释放掉，第二个类中的指针此时就是悬空指针，析构时会重复释放内存，造成崩溃"},"children":[]}]},{"data":{"id":"dedehzt57tc0","created":1763629553226,"text":"深拷贝"},"children":[{"data":{"id":"deder8mccow0","created":1763630277683,"text":"不仅复制成员的值，还会另外分配内存，复制指针指向的资源，使得源对象和拷贝对象互相不影响"},"children":[]},{"data":{"id":"dedeu0qp6tc0","created":1763630495625,"text":"一般需要自己重写拷贝构造函数，系统默认的拷贝构造函数是浅拷贝"},"children":[]}]}]},{"data":{"id":"dedcyorqybk0","created":1763625219168,"text":"C++多态的实现方式","expandState":"collapse"},"children":[{"data":{"id":"dedcyuh7n4o0","created":1763625231591,"text":"C++多态实现分为动态多态和静态多态","expandState":"expand"},"children":[{"data":{"id":"dedd4evibko0","created":1763625667812,"text":"动态多态（虚函数、纯虚函数实现的多态）（运行时调用）"},"children":[]},{"data":{"id":"dedd4j4rjzs0","created":1763625677079,"text":"静态多态（模板函数多态、函数重载多态）（编译时调用）"},"children":[]}]},{"data":{"id":"dedd8syglk80","created":1763626011922,"text":"C++的运行时多态必须满足两个条件："},"children":[{"data":{"id":"dedd9423z340","created":1763626036088,"text":"1. 必须通过基类的指针或者引用 调用虚函数（基类函数必须声明virtual）"},"children":[{"data":{"id":"dee7yt7qd1s0","created":1763712683248,"text":"因为如果我们通过派生类的指针指向虚函数时，实际上没发生动态多态，编译器在编译时直接就能确认对象为派生类型，这叫静态绑定"},"children":[]},{"data":{"id":"dee7zy3l96o0","created":1763712772246,"text":"通过基类指针或者引用调用虚函数时，这种在编译时无法确认调用哪个函数，只有运行时才知道，这叫动态绑定"},"children":[]}]},{"data":{"id":"dedd9caqw0w0","created":1763626054024,"text":"2. 派生类必须完成对该基类虚函数的重写"},"children":[]}]},{"data":{"id":"dee7rs5i6e00","created":1763712132388,"text":"C++中当基类指针或者引用指向一个派生类对象时，调用虚函数时，实际上会调用派生类中的虚函数，查询的也是派生类的虚函数表"},"children":[]}]},{"data":{"id":"dedewuwx0740","created":1763630718032,"text":"C++中this指针","priority":2,"expandState":"collapse"},"children":[{"data":{"id":"dedf4fqccmw0","created":1763631311896,"text":"this是指向当前对象的一个指针，指向当前对象的地址"},"children":[]},{"data":{"id":"dedf4zi5zs80","created":1763631354938,"text":"this指针可以用来访问当前类成员变量和成员函数，还可以用来返回当前对象的引用（*this）"},"children":[]},{"data":{"id":"dedf5pqnlts0","created":1763631412047,"text":"this指向常量成员变量时，指向的其实是常量对象的常量指针，所以this不可以用来修改常量成员变量"},"children":[]},{"data":{"id":"dedf6qy8dy80","created":1763631493046,"text":"C++中static函数是一种静态成员函数，和类相关，而不是和类的对象相关，所以静态函数没有this指针，它也不能用this指针访问非静态成员"},"children":[]}]},{"data":{"id":"dee78b8wvcg0","created":1763710606669,"text":"C++虚函数表","expandState":"collapse"},"children":[{"data":{"id":"dee7k0yghsg0","created":1763711524639,"text":"虚函数表是编译器对含有虚函数的类定义的一个函数指针数组，用来存该类中所有虚函数的入口地址"},"children":[]},{"data":{"id":"dee7kyfj3hs0","created":1763711597506,"text":"如果派生类继承了含有虚函数的基类，则派生类的虚函数表创建时会把基类的虚函数表复制过来，如果派生类对基类的虚函数进行了重写，则会在自己的表上覆盖自己自写的函数地址（虚函数表属于类）"},"children":[]},{"data":{"id":"dee7o3sswtc0","created":1763711844284,"text":"每个含有虚函数表的类创建的对象（注意！是对象，不是类）都会有一个虚表指针，通常在对象内存的最开头，指向该对象属于的类的虚函数表"},"children":[]},{"data":{"id":"dee7suzkn6o0","created":1763712216924,"text":"虚表指针是在构造函数中初始化"},"children":[]},{"data":{"id":"dee7v2p8eaw0","created":1763712390441,"text":"基类里含有虚函数，派生类重写了该函数，重写的函数前加不加virtual关键字有什么区别？"},"children":[{"data":{"id":"dee7v4lmsy80","created":1763712394577,"text":"没有任何区别"},"children":[]},{"data":{"id":"dee7vbql9280","created":1763712410114,"text":"C++中遵循一次虚，次次虚，也就是只要基类是虚函数，则之后的继承都是虚函数"},"children":[]},{"data":{"id":"dee7vt8lt880","created":1763712448209,"text":"C++11之前为了代码可读性都建议加上virtual关键字，C++11之后出了override关键字，都建议在重写的函数后加上override，能够防止写错函数名导致的BUG（编译器会检查）"},"children":[]}]}]},{"data":{"id":"dee80tzd2mw0","created":1763712841647,"text":"C++的纯虚函数","expandState":"expand"},"children":[{"data":{"id":"dee80ypoxfs0","created":1763712851947,"text":"纯虚函数是在基类中声明，但是没有实现的虚函数"},"children":[]},{"data":{"id":"dee82k462ds0","created":1763712976899,"text":"包含纯虚函数的类叫做抽象类，只能作为其他类的基类，不能实例化"},"children":[{"data":{"id":"dee85syjkkg0","created":1763713231242,"text":"原因很简单，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间"},"children":[]}]}]},{"data":{"id":"dee8679tleo0","created":1763713262399,"text":"构造函数不能是虚函数","expandState":"collapse"},"children":[{"data":{"id":"dee86wp6px40","created":1763713317747,"text":"语法上讲："},"children":[{"data":{"id":"dee88rxyu140","created":1763713464123,"text":"虚函数的主要目的是实现多态，即派生类可以重写基类的成员函数"},"children":[]},{"data":{"id":"dee89f2l68g0","created":1763713514468,"text":"构造函数负责初始化类的对象，每个类都应该有自己的构造函数，不需要多态"},"children":[]},{"data":{"id":"dee89weox0w0","created":1763713552205,"text":"派生类初始化时，优先自动调用基类的构造函数，初始化基类的成员，没有必要覆盖构造函数"},"children":[]}]},{"data":{"id":"dee8ap8gxwo0","created":1763713614956,"text":"虚函数表机制上讲："},"children":[{"data":{"id":"dee8av3om2g0","created":1763713627727,"text":"调用虚函数时，我们通过虚指针取找虚函数的地址，但是虚指针是在创建对象是，构造函数里面初始化的，如果构造函数是虚函数，此时虚指针还没初始化，就形成了死锁"},"children":[]},{"data":{"id":"dee8c4efv0w0","created":1763713726333,"text":"只有执行完对象的构造，虚函数表正确初始化，才能调用虚函数"},"children":[]}]}]},{"data":{"id":"dee8cneqrdk0","created":1763713767710,"text":"基类的析构函数必须是虚函数","expandState":"expand"},"children":[{"data":{"id":"dee8f8wzokg0","created":1763713971254,"text":"因为如果不添加virtual关键字，基类的析构函数是静态绑定，当定义了一个基类指针指向派生类的对象，删除指针时没有调用多态，就只会执行基类的析构函数，而不会执行派生类的析构函数，造成内存泄漏等问题"},"children":[]},{"data":{"id":"dee8gh67o740","created":1763714067590,"text":"如果添加了virtual关键字，就会运行时多态，先执行派生类的析构函数，再执行基类的析构函数"},"children":[]},{"data":{"id":"dee8hlduzag0","created":1763714155124,"text":"如果一个类中有虚函数，就意味着该类要被继承，就应该把析构函数设定为虚函数"},"children":[]},{"data":{"id":"dee8i0fvhwo0","created":1763714187897,"text":"类的默认析构函数不是虚函数，因为基类相比普通的类多了虚函数表，虚指针等东西，内存开销比普通类多，所以如果我们定义类时，编译器不知道我们是否将其作为基类，就不会多分配空间"},"children":[]}]},{"data":{"id":"dee8l058bqw0","created":1763714422346,"text":"C++类的成员函数不能即是模板函数又是虚函数","expandState":"collapse"},"children":[{"data":{"id":"dee8m6w7grk0","created":1763714515402,"text":"因为C++是分离编译的，模板函数需要在完全编译之后才能确定，虚函数需要类在编译完成时确定，两者冲突"},"children":[]}]}]},{"data":{"id":"debodknej9c0","created":1763454297956,"text":"C++内存管理","layout":null},"children":[{"data":{"id":"dee8psx5tzs0","created":1763714798442,"text":"C/C++内存的本质是什么？","priority":2,"expandState":"collapse"},"children":[{"data":{"id":"dee8y9ts4so0","created":1763715462156,"text":"一个巨大的，线性的，连续的字节数组，我们通过地址（指针）去访问和修改"},"children":[]},{"data":{"id":"dee90dqz8v40","created":1763715627422,"text":"内存分区","expandState":"expand"},"children":[{"data":{"id":"dee90g59rjc0","created":1763715632640,"text":"代码区"},"children":[{"data":{"id":"dee921qmotc0","created":1763715758008,"text":"存放二进制代码，只读"},"children":[]}]},{"data":{"id":"dee90m0qq8g0","created":1763715645426,"text":"全局/静态存储区"},"children":[{"data":{"id":"dee926vq4800","created":1763715769200,"text":"存放全局变量和静态变量"},"children":[]}]},{"data":{"id":"dee90sfng1c0","created":1763715659389,"text":"堆区"},"children":[{"data":{"id":"dee92iq9wrk0","created":1763715794992,"text":"存放局部变量、函数参数和返回地址（函数执行完去哪里执行）"},"children":[]},{"data":{"id":"dee92vjr3xk0","created":1763715822895,"text":"快、空间小、连续"},"children":[]},{"data":{"id":"dee93m9ube80","created":1763715881069,"text":"递归太深容易栈溢出"},"children":[]}]},{"data":{"id":"dee90qz67pk0","created":1763715656215,"text":"栈区","expandState":"expand"},"children":[{"data":{"id":"dee93xmvagw0","created":1763715905802,"text":"动态内存分配，比如malloc和new，需要手动释放"},"children":[]},{"data":{"id":"dee94dr98xk0","created":1763715940895,"text":"慢、空间大、碎片化"},"children":[]}]},{"data":{"id":"dee90uo0im00","created":1763715664248,"text":"常量区"},"children":[{"data":{"id":"dee94ti7t7c0","created":1763715975177,"text":"只读，常量数据"},"children":[]}]}]}]},{"data":{"id":"dee9i6y3s680","created":1763717023170,"text":"C/C++指针","priority":1,"expandState":"collapse"},"children":[{"data":{"id":"defxie90e5c0","created":1763886305662,"text":"想象内存是一个巨大的、由一个个小格子组成的储物柜，地址就是小格子的编号，数据就是小格子内的物品"},"children":[]},{"data":{"id":"defxj7oik480","created":1763886369726,"text":"指针本质也是一个变量，只不过里面放的数据是别的变量的地址"},"children":[]},{"data":{"id":"defxjqlbhp40","created":1763886410891,"text":"*和&"},"children":[{"data":{"id":"defxju05bcg0","created":1763886418318,"text":"&就是取地址"},"children":[]},{"data":{"id":"defxk3i80080","created":1763886439002,"text":"*在使用时是解引用"},"children":[]},{"data":{"id":"defxkcpc4dk0","created":1763886459024,"text":"*在定义时是告诉编译器这个变量是指针（int* p）"},"children":[]}]},{"data":{"id":"defxl4njimw0","created":1763886519865,"text":"指针的类型是为了告诉指针一次的步长，如果是int*，就是p+1内存地址一次增加4个字节"},"children":[]},{"data":{"id":"degsm3efjxc0","created":1763974049909,"text":"void指针"},"children":[{"data":{"id":"degsm7w7mrs0","created":1763974059691,"text":"void作为函数参数时，就是代表参数为空"},"children":[]},{"data":{"id":"degsmh5d3wg0","created":1763974079835,"text":"void *ptr就是指通用指针，可以存放任何类型数据的引用"},"children":[]},{"data":{"id":"degsnk485pc0","created":1763974164661,"text":"不能对void指针进行解引用，因为解引用本质上是编译器根据指针的类型从指针指向的内存连续取N个字节，但是void*指针，编译器不知道它指向的是int、char或什么类型的指针，所以不能解引用"},"children":[]}]}]},{"data":{"id":"degspbewiug0","created":1763974302444,"text":"C/C++ 指针声明和定义","expandState":"collapse"},"children":[{"data":{"id":"degsr9we7ts0","created":1763974455876,"text":"int *p[3];和int (*p)[3];"},"children":[{"data":{"id":"degsraz4iq00","created":1763974458218,"text":"int *p[3]，p是一个指针数组，p先和【】结合，代表一个数组，然后是int *，表示里面存放的都是int*类型"},"children":[]},{"data":{"id":"degsrzfcnjk0","created":1763974511442,"text":"int  (*p)[3], p是一个指针，指向一个大小为3的数组"},"children":[]}]},{"data":{"id":"degsu5ucm3k0","created":1763974682138,"text":"int p(int);"},"children":[{"data":{"id":"degsu7v4ye00","created":1763974686539,"text":"函数声明，从 p 处起，先与 () 结合，说明 p 是一个函数。然后进入 () 里分析，说明该函数有一个整型变量的参数，之后再与外面的 int 结合，说明函数的返回值是一个整型数据。"},"children":[]}]},{"data":{"id":"degsuju4m740","created":1763974712599,"text":"int (*p)(int);"},"children":[{"data":{"id":"degsukxnmwg0","created":1763974714990,"text":"函数指针，从 p 处开始，先与指针结合，说明 p 是一个指针。然后与()结合，说明指针指向的是一个函数。之后再与()里的int结合，说明函数有一个int型的参数，再与最外层的int结合，说明函数的返回类型是整型，所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。"},"children":[]}]},{"data":{"id":"degsv2yg36o0","created":1763974754219,"text":"int* (*p(int))[3];"},"children":[{"data":{"id":"degsv3qzbxc0","created":1763974755945,"text":"复杂声明，p先和（）结合，说明p是一个函数，函数参数为int类型，然后和外面*结合，说明返回的是一个指针，然后和[]结合，说明返回的指针指向的是一个数组，然后和int*结合，说明数组里存放的是int*类型"},"children":[]}]}]},{"data":{"id":"degt6d95hqo0","created":1763975638640,"text":"C/C++指针和引用的区别","expandState":"collapse"},"children":[{"data":{"id":"degt6kd9og00","created":1763975654127,"text":"指针是一个变量，存储另一个变量的地址，可以重新指向（常量指针除外）"},"children":[]},{"data":{"id":"degt6xrso880","created":1763975683303,"text":"引用是变量的别名，不是变量，一旦绑定不能更改"},"children":[]},{"data":{"id":"degt7msic2o0","created":1763975737766,"text":"指针可以为空（nullptr），引用必须绑定一个变量"},"children":[]},{"data":{"id":"degt7yhd3ts0","created":1763975763214,"text":"指针使用需要解运用，引用可以直接使用，无需解引用"},"children":[]}]},{"data":{"id":"degthplu7js0","created":1763976527535,"text":"C++ 中指针传递、值传递、引用传递","expandState":"collapse"},"children":[{"data":{"id":"degthrsmox40","created":1763976532299,"text":"值传递：实参的值传给形参，形参的修改不影响实参"},"children":[]},{"data":{"id":"degti49w53c0","created":1763976559464,"text":"引用传递：实参的引用传给形参，形参的修改影响实参"},"children":[]},{"data":{"id":"degtim7k15s0","created":1763976598505,"text":"指针传递：实参的地址传给形参，形参的修改影响实参"},"children":[]}]},{"data":{"id":"degtlq7s4mw0","created":1763976842318,"text":"C++ RAII ","expandState":"collapse"},"children":[{"data":{"id":"degtlqxbkw80","created":1763976843862,"text":"RAII（Resource Acquisition Is Initialization）资源获取即初始化"},"children":[]},{"data":{"id":"degtsdxx5k00","created":1763977364150,"text":"核心思想：把资源（内存、锁、文件等）的获取和释放绑定到某个对象的生命周期上，这样在作用域结束时，无论是否异常都能自动释放资源"},"children":[]},{"data":{"id":"degttm9eby80","created":1763977460622,"text":"大多数情况是定义的对象是在函数里，是局部变量，存放到栈上，当生命周期结束，会自动执行析构函数，释放资源"},"children":[]},{"data":{"id":"degtuw32o2o0","created":1763977560372,"text":"一般设计RAII类需要4步"},"children":[{"data":{"id":"degtv2w1f800","created":1763977575184,"text":"1. 设计一个类来封装资源，资源可以是内存、文件、锁、网络接口等"},"children":[]},{"data":{"id":"degtvl4tadc0","created":1763977614896,"text":"2. 构造函数里执行资源的初始化，比如内存申请，文件打开，申请锁等"},"children":[]},{"data":{"id":"degtw0135nk0","created":1763977647323,"text":"3. 析构函数里执行资源的释放，比如释放内存、关闭文件、释放锁"},"children":[]},{"data":{"id":"degtwd3n8j40","created":1763977675776,"text":"4. 利用C++的作用域规则，在我们希望执行的作用域内申请该类的对象，这样作用域结束就自动释放"},"children":[]}]}]},{"data":{"id":"degtzba7t2o0","created":1763977906912,"text":"C++智能指针","priority":1,"expandState":"collapse"},"children":[{"data":{"id":"dehtz33hctc0","created":1764079449047,"text":"智能是一种基于RAII思想的管理动态内存的类对象，在C++11引入，目的是解决C++开发过程中的内存泄漏、野指针等问题"},"children":[]},{"data":{"id":"dehu0l4ucwg0","created":1764079566676,"text":"C++标准库<memory>提供3种智能指针"},"children":[{"data":{"id":"dehu1q0fjk80","created":1764079655657,"text":"std::unique_ptr(独占智能指针)"},"children":[{"data":{"id":"dehu83akk0w0","created":1764080154753,"text":"独占：同一时刻只能有一个unique_ptr指向对象"},"children":[]},{"data":{"id":"dehu8fya5cg0","created":1764080182308,"text":"不可复制，不能让多个指针指向同一块内存"},"children":[]},{"data":{"id":"dehu8qlp1yo0","created":1764080205492,"text":"可移动：可以通过move()将所有权给另一个unique_ptr"},"children":[]},{"data":{"id":"dehu97385nk0","created":1764080241380,"text":"零开销：默认情况下，大小和裸指针一样"},"children":[]}]},{"data":{"id":"dehu25b05jk0","created":1764079688948,"text":"std::shared_ptr（共享智能指针）"},"children":[{"data":{"id":"dehua9ilpt40","created":1764080325028,"text":"引用计数：可以有多个shared_ptr指向同一个对象，内部维护一个控制块，记录有多少个"},"children":[]},{"data":{"id":"dehuatt4qg80","created":1764080369200,"text":"自动释放：每增加一个shared_ptr，就计数+1，销毁或重置一个就计数-1，计数归零时，对象被释放"},"children":[]},{"data":{"id":"dehubvrpyaw0","created":1764080451833,"text":"可复制、可移动"},"children":[]},{"data":{"id":"dehuby8e3080","created":1764080457194,"text":"开销比unique_ptr大"},"children":[]}]},{"data":{"id":"dehu2m4s0s80","created":1764079725577,"text":"std::weak_ptr（辅助智能指针）"},"children":[{"data":{"id":"dehuw8ai20w0","created":1764082046373,"text":"配合shared_ptr使用，解决循环引用的问题"},"children":[]},{"data":{"id":"dehux71cws00","created":1764082122007,"text":"指向shared_ptr管理的对象，但是不会增加引用计数"},"children":[]},{"data":{"id":"dehuxmy4grk0","created":1764082156640,"text":"访问受限，不能直接通过->和*访问对象，必须调用.lock()方法升级为shared_ptr才能访问（如果对象还存活）"},"children":[]}]}]},{"data":{"id":"dehulxp5huo0","created":1764081239673,"text":"手写C++ shared_ptr"},"children":[{"data":{"id":"dehummhu9dc0","created":1764081293650,"text":"shared_ptr的double free问题"},"children":[{"data":{"id":"dehumu8ky000","created":1764081310504,"text":"一块内存空间被释放两次"},"children":[]},{"data":{"id":"dehun1gl8cg0","created":1764081326226,"text":"原因："},"children":[{"data":{"id":"dehun7pcrj40","created":1764081339817,"text":"1. 使用原指针（裸指针）直接创建多个shared_ptr，没有使用make_shared工厂函数，引起多个独立的引用计数"},"children":[]},{"data":{"id":"dehuoou5mw00","created":1764081455477,"text":"2. 通过.get()方法获取了内部的裸指针，然后释放了，当shared_ptr计数归零时又释放了一次，两次free"},"children":[]},{"data":{"id":"dehupepu7080","created":1764081511812,"text":"3. 类内部使用this指针"},"children":[]},{"data":{"id":"dehupx61yao0","created":1764081551974,"text":"4. 循环引用，两个或者多个shared_ptr互相引用，导致计数出现问题"},"children":[]}]},{"data":{"id":"dehuqj9m78o0","created":1764081600079,"text":"解决方法："},"children":[{"data":{"id":"dehuqn6mgy80","created":1764081608605,"text":"使用make_shared（C++14引入）创建shared_ptr实例"},"children":[]},{"data":{"id":"dehur4pus0g0","created":1764081646773,"text":"对于可能产生循环引用的情况，使用weak_ptr"},"children":[]}]}]},{"data":{"id":"dehuvce8r6g0","created":1764081976942,"text":"具体手写"},"children":[]}]}]},{"data":{"id":"dehv11gg4dk0","created":1764082423316,"text":"malloc-free和new-delete","priority":1},"children":[{"data":{"id":"dehv51mug000","created":1764082737159,"text":"malloc-free"},"children":[{"data":{"id":"dehv54oqeq80","created":1764082743804,"text":"C语言标准库中的一种函数，C++也可以调用"},"children":[]},{"data":{"id":"dehv5goa8o00","created":1764082769898,"text":"malloc"},"children":[{"data":{"id":"dehv5k7cnc80","created":1764082777581,"text":"只负责分配指定大小字节的内存块，返回为void*"},"children":[]},{"data":{"id":"dehv5xg1g2o0","created":1764082806405,"text":"调用后需要强制类型转换，比如：int* a = (int*)malloc(sizeof(int))"},"children":[]},{"data":{"id":"dehv6sno2400","created":1764082874346,"text":"无法初始化，没有调用构造函数，如果malloc一个类，是没有调用构造函数的"},"children":[]},{"data":{"id":"dehvbhz9nuw0","created":1764083242924,"text":"分配失败返回NULL"},"children":[]}]},{"data":{"id":"dehv5iingiw0","created":1764082773911,"text":"free"},"children":[{"data":{"id":"dehv8fn67mw0","created":1764083002747,"text":"释放指针指向的内存"},"children":[]},{"data":{"id":"dehv8jej1280","created":1764083010931,"text":"不会调用析构函数"},"children":[]}]},{"data":{"id":"dehvc94o9qw0","created":1764083302024,"text":"malloc-free不可重载"},"children":[]}]},{"data":{"id":"dehv8orr2sw0","created":1764083022615,"text":"new-delete"},"children":[{"data":{"id":"dehv8sr4zjk0","created":1764083031285,"text":"C++中的一种运算符，专门为对象设计"},"children":[]},{"data":{"id":"dehv9avz09c0","created":1764083070759,"text":"new"},"children":[{"data":{"id":"dehv9irrqls0","created":1764083087919,"text":"会自动计算大小，不用手动传入大小，自动调用构造函数"},"children":[]},{"data":{"id":"dehveh83hv40","created":1764083476374,"text":"new时分为未初始化和初始化为0，new T和new T()"},"children":[]},{"data":{"id":"dehvb6h8dko0","created":1764083217889,"text":"返回具体的指针类型，不用强制类型转换"},"children":[]},{"data":{"id":"dehv9z39sg00","created":1764083123443,"text":"使用[]可以new创建数组"},"children":[]},{"data":{"id":"dehvbpuuh2g0","created":1764083260071,"text":"分配失败抛出异常"},"children":[]}]},{"data":{"id":"dehv9dvlqe80","created":1764083077267,"text":"delete"},"children":[{"data":{"id":"dehvacauwuw0","created":1764083152200,"text":"自动调用析构函数"},"children":[]},{"data":{"id":"dehvaiarjm00","created":1764083165255,"text":"可以释放单个对象，也可以用[]释放多个对象数组"},"children":[]}]},{"data":{"id":"dehvbzbmwcg0","created":1764083280677,"text":"new-delete可以重载"},"children":[]}]},{"data":{"id":"dehvfgo6u4w0","created":1764083553534,"text":"malloc-free和new-delete不能混用，因为一对不调用构造函数和析构函数，一对调用"},"children":[]},{"data":{"id":"dehvg0tcovk0","created":1764083597382,"text":"new-delete内部具体实现是通过malloc-free"},"children":[]}]},{"data":{"id":"deihfw6ht600","created":1764145651711,"text":"C++内存泄漏","priority":1},"children":[{"data":{"id":"deihj5jc3vk0","created":1764145907171,"text":"内存泄漏就是程序分配了动态内存但是没有释放一直被占用，导致内存无法再次访问或使用"},"children":[]},{"data":{"id":"deihlexdf3s0","created":1764146084339,"text":"常见的内存泄漏场景："},"children":[{"data":{"id":"deihlv59e6w0","created":1764146119644,"text":"1. 使用malloc或者new之后忘记释放"},"children":[]},{"data":{"id":"deihm9lb67c0","created":1764146151090,"text":"2. 发生异常或者提前返回，导致释放的程序还没处理"},"children":[]},{"data":{"id":"deihmo4993c0","created":1764146182710,"text":"3. 指针覆盖，把一个指向动态内存的指针重新赋值，导致指向原来内存的地址丢失，无法被释放"},"children":[]},{"data":{"id":"deihnmh0ubk0","created":1764146257493,"text":"4. 错误的释放方式，new一个数组，但是使用delete，正确应该是delete[]"},"children":[]},{"data":{"id":"deihp4q2k680","created":1764146375586,"text":"5. 多态陷阱，父类的析构函数不是虚函数，这样调用父类指针指向子类对象后，delete父类指针时，不会运行时多态调用子类的析构函数"},"children":[]},{"data":{"id":"deihqjliapc0","created":1764146486326,"text":"6. shared_ptr循环引用，导致两个指针的计数永远不为0，申请内存无法释放"},"children":[]}]},{"data":{"id":"deihr64l1e00","created":1764146535369,"text":"检查内存泄漏方法"},"children":[{"data":{"id":"deihs3ov10o0","created":1764146608429,"text":"1. Valgrind(Memcheck)工具，Linux/macOS环境下"},"children":[{"data":{"id":"deihsyr7b140","created":1764146676050,"text":"用法：valgrind --leak-check=full ./your_program"},"children":[]}]},{"data":{"id":"deihu5x7v5s0","created":1764146770016,"text":"2. AddressSanitizer, 集成在GCC/Clang中"},"children":[{"data":{"id":"deihum6b2u80","created":1764146805394,"text":"编译时加上 -fsanitize=address -g"},"children":[]}]},{"data":{"id":"deihvfuaewo0","created":1764146869971,"text":"3. CRT Debug Library windows/visual Studio环境"},"children":[{"data":{"id":"deihw3zj7cw0","created":1764146922530,"text":"在 main 退出前调用 _CrtDumpMemoryLeaks();"},"children":[]}]}]},{"data":{"id":"deihwdmm0ag0","created":1764146943517,"text":"如何避免内存泄漏"},"children":[{"data":{"id":"deihx35c2ew0","created":1764146999069,"text":"分支主题"},"children":[]}]}]}]},{"data":{"id":"debodm96usg0","created":1763454301450,"text":"分支主题","layout":null},"children":[]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}