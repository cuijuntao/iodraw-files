{"root":{"data":{"id":"debo8gf7ob40","created":1763453896933,"text":"C++面试指北"},"children":[{"data":{"id":"debobh9ww340","created":1763454133882,"text":"C++基础语法","layout":null},"children":[{"data":{"id":"decjvgs5qeo0","created":1763543154498,"text":"C++的构建过程","layout":null,"expandState":"collapse"},"children":[{"data":{"id":"decjwcqy0lk0","created":1763543224082,"text":"1. 预处理"},"children":[{"data":{"id":"decjx566ksg0","created":1763543285953,"text":"处理#define、#include等，生成.i文件"},"children":[]}]},{"data":{"id":"decjwf5uv2g0","created":1763543229337,"text":"2. 编译"},"children":[{"data":{"id":"decjxj28vy00","created":1763543316190,"text":"将预处理之后代码翻译成汇编语言，生成.s文件"},"children":[]}]},{"data":{"id":"decjwkvz2xc0","created":1763543241801,"text":"3. 汇编"},"children":[{"data":{"id":"decjxvfyzbc0","created":1763543343142,"text":"将汇编语言翻译成机器码，生成.o文件"},"children":[]}]},{"data":{"id":"decjwnkqugg0","created":1763543247652,"text":"4. 链接"},"children":[{"data":{"id":"decjy731nwg0","created":1763543368481,"text":"将所有的.o文件和库文件结合，生成最终可执行文件.exe或者a.out"},"children":[]}]}]},{"data":{"id":"deboekxjcvs0","created":1763454376933,"text":"sizeof","expandState":"collapse","layout":null},"children":[{"data":{"id":"debofwfanqw0","created":1763454480315,"text":"指针的大小是固定的，取决于处理器的位数，64位的大小是8","progress":null,"layout":null},"children":[]},{"data":{"id":"debogadtb5c0","created":1763454510701,"text":"数组作为函数参数传递时会退化成指针，大小按照指针计算","layout":null},"children":[]},{"data":{"id":"debohm07o2o0","created":1763454614364,"text":"结构体大小要考虑字节对齐","layout":null},"children":[]},{"data":{"id":"debohx2djvk0","created":1763454638439,"text":"直接计算字符串数组的时候要算上末尾的‘\\0’，也就是正常长度+1","layout":null},"children":[]}]},{"data":{"id":"deboez9s0ds0","created":1763454408148,"text":"sizeof和strlen的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"deboj44yo0w0","created":1763454732197,"text":"strlen是C标准库中的一个函数，计算C风格字符串（以'\\0'结尾的字符串数组）的长度，不包括‘\\0’","layout":null},"children":[]},{"data":{"id":"debok9fh7f40","created":1763454822081,"text":"sizeof是C++编译期间计算的操作符，用于计算数据类型和对象的字节数，当计算的是字符串数组时，包括结尾的'\\0'","layout":null},"children":[]}]},{"data":{"id":"deboisn8pg80","created":1763454707181,"text":"数组作为参数时退化成指针","expandState":"collapse","layout":null},"children":[{"data":{"id":"deboq3xz7x40","created":1763455280324,"text":"如果是把数组当做正常的参数传递给一个函数时，此时传递的是数组的指针，所以sizeof就是指针的大小","layout":null},"children":[]},{"data":{"id":"deboqpah2bs0","created":1763455326792,"text":"但是如果传递的是一个数组的引用（保留大小信息），此时函数内部sizeof就数组的正常大小","expandState":"collapse","layout":null},"children":[{"data":{"id":"debpdv18y0g0","created":1763457141671,"text":"// func 的参数是一个对“包含5个int的数组”的引用\nvoid func(int (&arr)[5]) {\n\tstd::cout << \"通过引用传递, sizeof(arr) = \" << sizeof(arr) << std::endl;\n}\nint main() {\n\tint my_arr[5] = {};\n\tfunc(my_arr); // 传递 my_arr\n\t// int another_arr[6] = {};\n\t// func(another_arr); // 编译错误！因为类型不匹配（[6] vs [5]）\n}","layout":null},"children":[]}]}]},{"data":{"id":"deboeztn5000","created":1763454409349,"text":"const关键字（*****）","expandState":"collapse","priority":1,"layout":null},"children":[{"data":{"id":"debozws567k0","created":1763456048376,"text":"const是一个关键字，用来表示常量，可以修饰变量、函数、指针","layout":null},"children":[]},{"data":{"id":"debp0n0dzo00","created":1763456105470,"text":"1.const修饰变量时，正常是不能被修改的，使用const_cast可以强行修改，但是一般会被编译器优化，不起作用","layout":null},"children":[]},{"data":{"id":"debp28njj940","created":1763456230947,"text":"2.const修饰函数参数时，证明函数内部不会修改该参数，如果内部修改了，编译时会报错","layout":null},"children":[]},{"data":{"id":"debp2qjsj7s0","created":1763456269902,"text":"3.const可以修改函数返回值，这样可以保证函数返回值更安全，不会被误修改","layout":null},"children":[]},{"data":{"id":"debp3kdlxgg0","created":1763456334832,"text":"4.const修饰指针或者引用","expandState":"expand","layout":null},"children":[{"data":{"id":"debp4559nc00","created":1763456380040,"text":"1.指向只读变量的指针，可以更改指针指向的只读变量，但是不能通过指针更改只读变量的值","layout":null},"children":[]},{"data":{"id":"debp632rl8o0","created":1763456532263,"text":"2.只读指针，初始化时必须指向一个地址，可以通过指针修改变量的值，但是不能更改指向的变量","layout":null},"children":[]},{"data":{"id":"debp6sw1czs0","created":1763456588453,"text":"3.只读指针指向只读变量，const int a =10; const int* const p = &a,指针指向的变量不能修改，也不能通过指针修改变量的值","layout":null},"children":[]},{"data":{"id":"debp8544ye80","created":1763456693428,"text":"4.常量引用，无法通过常量引用修改常量的值，只是引用","layout":null},"children":[]}]},{"data":{"id":"debp98t86540","created":1763456779840,"text":"4.修饰成员函数","layout":null},"children":[{"data":{"id":"debp9dmbyqw0","created":1763456790307,"text":"const修饰成员函数时，就可以让const对象调用const成员函数，正常const对象无法调用非const成员函数","layout":null},"children":[]}]}]},{"data":{"id":"debof07mu2o0","created":1763454410195,"text":"static关键字（*****）","expandState":"collapse","priority":1,"layout":null},"children":[{"data":{"id":"debpftl44qo0","created":1763457295247,"text":"可以用于变量、函数、和类","layout":null},"children":[]},{"data":{"id":"debpg3qyx6w0","created":1763457317369,"text":"1.修饰全局变量，把该变量的作用域限定到当前文件中，其他文件无法访问该变量，该变量会在程序启动时初始化，声明周期和函数一样长（变量放在全局存储区）","layout":null},"children":[]},{"data":{"id":"debpizic3zs0","created":1763457543232,"text":"2.修饰局部变量，可以使得变量在函数结束调用后不会被销毁，下次调用函数可以继续使用，该局部变量放在全局存储区，生命周期贯穿整个程序","layout":null},"children":[]},{"data":{"id":"debpk3psyeg0","created":1763457630755,"text":"3.修饰函数，使得函数的作用域限于该文件，其他文件无法访问该函数，此时该函数的链接属性就是内部链接，其他文件可以定义一样名字的函数，但是不能声明引入该函数","layout":null},"children":[]},{"data":{"id":"debpmqyx2dc0","created":1763457838100,"text":"4.修饰类成员变量和类成员函数，这些成员在所有类对象中共享，可以使得不需要创建对象就可以访问","layout":null},"children":[]}]},{"data":{"id":"decjgpr0irc0","created":1763541998558,"text":"C++语言层面的链接属性","priority":2,"expandState":"collapse","layout":null},"children":[{"data":{"id":"decjgwhzhs00","created":1763542013249,"text":"1.外部链接","layout":null},"children":[{"data":{"id":"decjmrpw7ts0","created":1763542473029,"text":"普通的全局变量，非static","layout":null},"children":[]},{"data":{"id":"decjmvbdooo0","created":1763542480858,"text":"普通的函数，非static，非inline","layout":null},"children":[]},{"data":{"id":"decjn8ojhvk0","created":1763542509952,"text":"使用extern声明的变量或函数","layout":null},"children":[]}]},{"data":{"id":"decjnjbhju80","created":1763542533107,"text":"2.内部链接","layout":null},"children":[{"data":{"id":"decjnm9wwt40","created":1763542539543,"text":"static修饰的全局变量或函数","layout":null},"children":[]},{"data":{"id":"decjo0faiw80","created":1763542570343,"text":"C++中const修饰的全局变量，C语言中const修饰的是外部链接","layout":null},"children":[]},{"data":{"id":"decjoff0gq80","created":1763542602978,"text":"匿名命名空间中的所有内容","layout":null},"children":[{"data":{"id":"decjox3nk2o0","created":1763542641473,"text":"namespace {\n\tvoid helperFunction() { ... } // 自动具有内部链接\n\tclass LocalHelper { ... };    // 类型也可以限制在内部\n}","layout":null},"children":[]}]}]},{"data":{"id":"decjomm7nxc0","created":1763542618650,"text":"3. 无链接","layout":null},"children":[{"data":{"id":"decjoqlq2ds0","created":1763542627328,"text":"代码块内的内容","layout":null},"children":[]},{"data":{"id":"decjpbmr6w00","created":1763542673103,"text":"局部变量","layout":null},"children":[]},{"data":{"id":"decjpf6fjrs0","created":1763542680823,"text":"函数参数","layout":null},"children":[]},{"data":{"id":"decjpl2ocv40","created":1763542693656,"text":"函数体内部定义的类或者结构体","layout":null},"children":[]}]}]},{"data":{"id":"debof0phvi80","created":1763454411275,"text":"volatile","expandState":"collapse","layout":null},"children":[{"data":{"id":"debppdelbmo0","created":1763458043666,"text":"用于修饰变量，表示变量的值可能在任何时候被外部因素更改","layout":null},"children":[]},{"data":{"id":"debppq1q6hs0","created":1763458071186,"text":"当一个变量被声明为volatile，编译器会禁止对该变量优化，确保每次读取该变量是从内存中，而不是从寄存器或者缓存中读取","layout":null},"children":[]},{"data":{"id":"debpstg4y400","created":1763458313680,"text":"当volatile声明一个变量，就是告诉编译器该变量可能会被寄存器其他地方改变，因为编译器为了效率，可能把变量缓存到寄存器中，不再从内存中读取（慢），比如多线程情况，另一个线程可能修改了这个变量，编译器应该重新从内存读取，volatile就是为了这种情况","layout":null},"children":[]}]},{"data":{"id":"debof1at1u80","created":1763454412564,"text":"字节对齐","expandState":"collapse","layout":null},"children":[{"data":{"id":"decijvkk48w0","created":1763539425211,"text":"字节对齐是内存分配的一种策略；在分配内存时，编译器会自动调整数据结构的内存布局，使得数据成员的起始地址和其自然对齐边界（一般为自己大小的倍数）相匹配","layout":null},"children":[]},{"data":{"id":"decilenohd40","created":1763539545122,"text":"如果数据存储不进行适当对齐，可能导致存取效率低下","layout":null},"children":[]},{"data":{"id":"decilxi64e80","created":1763539586148,"text":"字节对齐有助于提高内存访问速度，但是可能造成一些内存空间浪费","layout":null},"children":[]},{"data":{"id":"decimzcncg80","created":1763539668532,"text":"需要额外注意结构体的对齐，结构体中，每个成员都会为了使下一个成员能够在合适位置开始而填充自己后面的字节，最后一个成员会为了对齐整个结构体而填充，结构体的对齐是根据最长成员的大小来对齐，（也就是倍数）","layout":null},"children":[]},{"data":{"id":"decipffb2740","created":1763539860250,"text":"更改对齐规则：全局可以使用#pragma pack来更改对齐规则，但是会降低访问性能，C++11及以上，可以通过alignas关键字来指定对齐要求","layout":null},"children":[]},{"data":{"id":"deciqqq365s0","created":1763539963210,"text":"大多数动态内存分配函数（malloc和new）会自动分配对齐的内存","layout":null},"children":[]}]},{"data":{"id":"decir9n4u5s0","created":1763540004391,"text":"字节序：大端序和小端序","expandState":"collapse","layout":null},"children":[{"data":{"id":"deciridmh080","created":1763540023407,"text":"字节序指的是多字节数据类型（如整数，浮点数）中，字节在内存中的存储顺序","layout":null},"children":[]},{"data":{"id":"decish7wwow0","created":1763540099249,"text":"大端字节序是指高位字节存储在低地址处，低位字节存储在高地址处；小端字节序则是反过来","layout":null},"children":[]},{"data":{"id":"decitgsn8js0","created":1763540176690,"text":"网络传输过程中通常使用大端字节序","layout":null},"children":[]},{"data":{"id":"decitwvbt340","created":1763540211680,"text":"具体的操作系统（LinxuX86、windowsX86、mac）使用的是小端字节序","layout":null},"children":[]}]},{"data":{"id":"deciv0xlzig0","created":1763540298890,"text":"C++中的class和struct的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"deciv7upq1c0","created":1763540313952,"text":"C++为了兼容C语言保留了struct关键字，并扩充了含义","layout":null},"children":[]},{"data":{"id":"deciw0hhm740","created":1763540376279,"text":"C语言中struct只能包含成员，不能包含成员函数，C++里的struct类似class,都可以包含","layout":null},"children":[]},{"data":{"id":"deciwqx6nx40","created":1763540433824,"text":"Class中成员默认是private属性，struct成员默认是public属性","layout":null},"children":[]},{"data":{"id":"deciwu1s3880","created":1763540440633,"text":"class继承默认是private继承，struct默认是public继承","layout":null},"children":[]},{"data":{"id":"deciy1g1f1k0","created":1763540535096,"text":"class可以用于定义模板参数，struct不能用来定义模板参数","layout":null},"children":[]}]},{"data":{"id":"deciylmtev40","created":1763540579042,"text":"c++中define和inline的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"decize0dh680","created":1763540640813,"text":"宏定义（#define）和内联函数（inline）都是为了减少函数调用开销和提高代码运行效率的机制","layout":null},"children":[]},{"data":{"id":"decj0a366p40","created":1763540710638,"text":"#define是预处理命令的一种，一般用来定义宏常量和创建宏函数","layout":null},"children":[]},{"data":{"id":"decj1o5poqo0","created":1763540819631,"text":"inline在函数开头声明，一般会把内联函数复制到调用处，使用空间换时间的策略来提高效率，但是具体是否复制需要根据编译器的判断，如果内联函数很长，可能不会复制，还是作为普通函数","layout":null},"children":[]},{"data":{"id":"decj330pkps0","created":1763540930344,"text":"#define和inline的主要区别在于#define不会进行类型检查只是简单的替换文本，可能导致错误，inline会进行类型检查，更加安全","layout":null},"children":[]}]},{"data":{"id":"decj46nkb200","created":1763541016620,"text":"c++中define和typedef的区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"decj4ib1vvk0","created":1763541041985,"text":"两者都是C++中用来定义别名的方法","layout":null},"children":[]},{"data":{"id":"decj54sjduo0","created":1763541090932,"text":"区别","expandState":"collapse","layout":null},"children":[{"data":{"id":"decj5f1oo6w0","created":1763541113253,"text":"1.语法，#define只是进行文本替换，不进行类型检查，typedef是一种类型定义关键字，会进行类型检查（编译阶段处理）","layout":null},"children":[]},{"data":{"id":"decj6jbvepc0","created":1763541200940,"text":"2.作用域，#define没有作用域的限制，宏定义之后就都可以使用，typedef有作用域的限制，通常定义浮渣类型的别名，方便进行维护","layout":null},"children":[]},{"data":{"id":"decj866jpnk0","created":1763541329048,"text":"3.模板支持，#define不支持模板，typedef支持模板","layout":null},"children":[]}]}]},{"data":{"id":"decj9ssa7s00","created":1763541456616,"text":"c++中的explicit","expandState":"collapse","layout":null},"children":[{"data":{"id":"decjc0jbaww0","created":1763541630216,"text":"explicit通常用于构造函数的声明中，防止隐式类型转换，当一个参数传给构造函数后，如果构造函数声明中使用了explicit关键字，就只能使用显示转换，不能隐式转换，防止编译器自动执行预期之外的类型转换","layout":null},"children":[]}]},{"data":{"id":"decjewzlork0","created":1763541857586,"text":"C++中extern的作用","expandState":"collapse","layout":null,"priority":1},"children":[{"data":{"id":"decjpycghn40","created":1763542722546,"text":"首先了解声明和定义，extern是声明","layout":null},"children":[]},{"data":{"id":"decjq8wgjko0","created":1763542745523,"text":"C++支持分离式编译，支持文件之间共享数据，extern就是告诉编译器这个变量在别处有定义，让去别处找","layout":null},"children":[]},{"data":{"id":"decjr2u7gn40","created":1763542810691,"text":"常量全局变量的外部链接，全局常量默认是内部链接的，如果想在文件之间共享，需要定义时指明extern，比如：","layout":null},"children":[{"data":{"id":"decjsa624y80","created":1763542905009,"text":"//fileA.cpp\nextern const int i = 1;        //定义\n//fileB.cpp                    //声明\nextern const int i;","layout":null},"children":[]}]},{"data":{"id":"decjzbeudbk0","created":1763543456266,"text":"c++中可以用extern C关键字来指定外部C链接，从而使用一些C的静态库"},"children":[]},{"data":{"id":"decjt7bmm0o0","created":1763542977179,"text":"extern在编译和链接的过程，编译期间，编译器会在extern处声明一个符号引用，在链接期间，链接器会把多个目标文件链接成一个可执行文件，会找到声明的符号引用，然后在其他源文件中找到对应的定义，然后链接起来","layout":null},"children":[]}]},{"data":{"id":"decjzy4ywhs0","created":1763543505735,"text":"extern C","expandState":"collapse"},"children":[{"data":{"id":"deck05s3z8w0","created":1763543522372,"text":"如果不用extern C，但是还需要使用C语言中的某些函数等，就会因为C++和C语言在编译和链接时使用的命名规则不同而报错，导致C++无法调用C语言编写的函数或变量","expandState":"expand"},"children":[]},{"data":{"id":"deck24wnink0","created":1763543677198,"text":"使用extern C 之后，在对应位置写入C语言函数或者变量，外面的C++程序就能调用其中的C语言代码，比如：","expandState":"expand"},"children":[{"data":{"id":"deck2x828w00","created":1763543738838,"text":"// C 语言代码\n#include <stdio.h>\n\nvoid print_message(const char* message) {\n\tprintf(\"%s\\n\", message);\n}","expandState":"expand"},"children":[]},{"data":{"id":"deck336no940","created":1763543751813,"text":"// C++ 代码\nextern \"C\" {\n\t// 声明 C 语言函数\n\tvoid print_message(const char* message);\n}\nint main() {\n\t// 调用 C 语言函数\n\tprint_message(\"Hello, world!\");\n\treturn 0;\n}"},"children":[]}]}]},{"data":{"id":"deck499ckgg0","created":1763543843401,"text":"C++ mutable","expandState":"collapse"},"children":[{"data":{"id":"deck4mqsft40","created":1763543872754,"text":"mutable是一个C++的关键字，修饰类中的成员变量，表示该变量在一个const成员函数内也能被修改，mutable中文意思是多变的，是constant的反义词"},"children":[]}]},{"data":{"id":"deck63z7iw80","created":1763543988632,"text":"C++ 的四种强制类型转换"},"children":[{"data":{"id":"deck6a0516o0","created":1763544001749,"text":"C语言中一般使用（typename）expression来进行强制类型转换，C++则是更推荐使用下面4种"},"children":[]},{"data":{"id":"deck8j0h8o80","created":1763544178089,"text":"static_cast"},"children":[{"data":{"id":"deck964zgug0","created":1763544228428,"text":"用法: static_cast <new_type> (expression)"},"children":[]},{"data":{"id":"deck98zzuxs0","created":1763544234656,"text":"一般和C语言强制类型转换相同"},"children":[]}]},{"data":{"id":"deck8q35feo0","created":1763544193488,"text":"dynamic_cast"},"children":[]},{"data":{"id":"deck8uqha1s0","created":1763544203606,"text":"const_cast"},"children":[]},{"data":{"id":"deck8y4sfhk0","created":1763544211002,"text":"reinterpret_cast"},"children":[]}]}]},{"data":{"id":"debodg0e1s00","created":1763454287857,"text":"分支主题","layout":null},"children":[]},{"data":{"id":"debodknej9c0","created":1763454297956,"text":"分支主题","layout":null},"children":[]},{"data":{"id":"debodm96usg0","created":1763454301450,"text":"分支主题","layout":null},"children":[]}]},"template":"right","theme":"fresh-blue","version":"1.4.43"}